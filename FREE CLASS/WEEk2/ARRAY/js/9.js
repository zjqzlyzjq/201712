// var ary = [12, 13, 23, 14, 16, 11];
// ary.sort(function (a, b) {
//     return a - b;
// });
// console.log(ary);

//=>冒泡排序
//原理：让数组中的当前项和后一项进行比较，如果当前项大于后一项，我们让两者交换位置（小->大）
/*
 * 第一轮比较
 *   12 13  [12, 13, 23, 14, 16, 11]
 *   13 23  [12, 13, 23, 14, 16, 11]
 *   23 14  [12, 13, 14, 23, 16, 11]
 *   23 16  [12, 13, 14, 16, 23, 11]
 *   23 11  [12, 13, 14, 16, 11, 23]
 * 第二轮比较
 *   12 13 [12, 13, 14, 16, 11, 23]
 *   13 14 [12, 13, 14, 16, 11, 23]
 *   14 16 [12, 13, 14, 16, 11, 23]
 *   16 11 [12, 13, 14, 11, 16, 23]
 * ...
 * 每一轮从前到后两两比较，虽然不一定实现最后的排序效果，但是可以把当前最大的放在末尾
 * 具体比较的轮数：ary.length-1  数组有多长，我们只需要把总长度-1个数分别放在末尾，即可实现最后的排序
 *
 * 第一轮比较5次：一共六个，不需要和自己比较
 * 第二轮比较4次：一共六个，不用和自己比，也不用和第一轮放在末尾的那个最大值比
 * 第三轮比较3次
 * ...
 * 每一轮比较的次数  ary.length-1(不用和自己比)-当前已经执行的轮数(执行一轮向末尾放一个最大值,这些值不需要再比较)
 *
 * a=12
 * b=13
 * a和b交换值
 * c=a;
 * a=b;
 * b=c;
 *
 * a=a+b;  25
 * b=a-b;  12
 * a=a-b;  13
 */

/*
 * bubble：冒泡排序
 *  @parameter
 *    ary：[array]需要实现排序的数组
 *  @return
 *    [array]排序后的数组(升序)
 * by team on 2017/10/19
 */
function bubble(ary) {
    //->外层循环控制的是比较的轮数
    for (var i = 0; i < ary.length - 1; i++) {
        //->里层循环控制每一轮比较的次数
        for (var j = 0; j < ary.length - 1 - i; j++) {
            //ary[j]:当前本次拿出来这一项
            //ary[j+1]:当前项的后一项
            if (ary[j] > ary[j + 1]) {
                //->当前这一项比后一项还要大,我们让两者交换位置
                var temp = ary[j];
                ary[j] = ary[j + 1];
                ary[j + 1] = temp;
            }
        }
    }
    return ary;
}

var ary = [12, 13, 23, 14, 16, 11];
console.log(bubble(ary));
